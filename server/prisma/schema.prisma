// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum MemberRole {
  PLAYER
  COACH
  ADMIN
  ORGANIZER
}

model Member {
  id        Int       @id @default(autoincrement()) // Primary key - ensures unique IDs
  firstName String
  lastName  String
  birthDate DateTime? // Optional birth date for filtering and tournament selection
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // USATT-style rating (numeric rating like 1200, 1500, etc.)
  rating Int?

  // New required fields
  email    String       @unique
  gender   Gender
  password String
  roles    MemberRole[]

  // New optional fields
  picture String? // Image URL or path
  phone   String?
  address String?

  // Password reset flag
  mustResetPassword Boolean @default(false) // Set to true when admin resets password, forces password change on next login
  
  // Forgot password reset token
  passwordResetToken String? // Token for password reset (forgot password flow)
  passwordResetTokenExpiry DateTime? // Expiration time for reset token

  // Rating history
  ratingHistory RatingHistory[]

  // Tournament participations
  tournamentParticipants TournamentParticipant[]

  @@index([email])
  @@map("members")
}

model RatingHistory {
  id           Int                @id @default(autoincrement())
  memberId     Int
  rating       Int? // Rating after this change
  ratingChange Int? // Change in rating (+/-)
  timestamp    DateTime           @default(now())
  reason       RatingChangeReason
  tournamentId Int? // Reference to tournament that caused this change
  matchId      Int? // Reference to match that caused this change (for MATCH_COMPLETED)

  member Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@index([memberId])
  @@index([timestamp])
  @@index([tournamentId])
  @@index([matchId])
  @@map("rating_history")
}

enum RatingChangeReason {
  TOURNAMENT_COMPLETED
  MATCH_COMPLETED
  PLAYOFF_MATCH_COMPLETED
  RESULT_CORRECTED
  MANUAL_ADJUSTMENT
  MEMBER_DEACTIVATED
}

// Tournament table: Contains information pertinent to ALL tournaments
// Basic tournaments: have players (TournamentParticipant) and matches (Match)
// Compound tournaments: consist of 2+ basic/compound tournaments (via parentTournamentId hierarchy)
// TournamentParticipants only exist for basic tournaments
model Tournament {
  id         Int              @id @default(autoincrement())
  name       String?          // Tournament name
  type       TournamentType   @default(ROUND_ROBIN)
  status     TournamentStatus @default(ACTIVE)
  cancelled  Boolean          @default(false) // True if tournament was cancelled
  createdAt  DateTime         @default(now())
  recordedAt DateTime         @updatedAt

  // Hierarchical structure: compound tournaments reference parent
  // If null, this is a root tournament (either basic or top-level compound)
  parentTournamentId Int?

  // Relations
  // Participants: only for basic tournaments (enforced at application level)
  participants   TournamentParticipant[]
  
  // Matches: only for basic tournaments (each match references one basic tournament)
  matches        Match[]
  
  // Bracket structure: only for PLAYOFF basic tournaments
  bracketMatches BracketMatch[]
  
  // Compound tournament configuration fields
  groupNumber          Int?     // For child tournaments: which group this is (1, 2, 3...)

  // Type-specific configuration (one-to-one relations)
  swissData                    SwissTournamentData?
  preliminaryRoundRobinConfig  PreliminaryRoundRobinConfig?

  // Self-referential relationship for parent-child tournaments (compound tournaments)
  parentTournament   Tournament?  @relation("TournamentHierarchy", fields: [parentTournamentId], references: [id], onDelete: Cascade)
  childTournaments   Tournament[] @relation("TournamentHierarchy")

  @@map("tournaments")
}

enum TournamentStatus {
  ACTIVE
  COMPLETED
}

// Tournament types: Basic tournaments have players and matches
// Compound tournaments consist of 2+ basic/compound tournaments
enum TournamentType {
  // Basic tournaments
  ROUND_ROBIN              // Round Robin tournament - no additional tables required
  PLAYOFF                  // Playoff tournament - uses BracketMatch table
  SWISS                    // Swiss tournament - uses SwissRound table (to be defined)
  
  // Compound tournaments
  MULTI_ROUND_ROBINS                  // Compound: multiple round robin tournaments
  PRELIMINARY_WITH_FINAL_PLAYOFF      // Compound: preliminary phase(s) + final playoff
  PRELIMINARY_WITH_FINAL_ROUND_ROBIN  // Compound: preliminary phase(s) + final round robin
}

// TournamentParticipants: identifies players playing in a basic tournament only
// Compound tournaments have no participants - participants are union of child tournaments
// Enforced at application level: only basic tournaments (ROUND_ROBIN, PLAYOFF, SWISS) have participants
model TournamentParticipant {
  id                 Int  @id @default(autoincrement())
  tournamentId       Int
  memberId           Int
  playerRatingAtTime Int? // Snapshot of rating when tournament started

  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  member     Member     @relation(fields: [memberId], references: [id], onDelete: Restrict)

  @@unique([tournamentId, memberId])
  @@index([tournamentId])
  @@index([memberId])
  @@map("tournament_participants")
}

// BracketMatch: Supporting table for PLAYOFF basic tournaments
// Stores the bracket layout for playoff tournaments
// Maintains bracket structure from start to finish, including unplayed matches
// References Match when both players are determined and match is created
model BracketMatch {
  id           Int      @id @default(autoincrement())
  tournamentId Int      // Foreign key to tournament (must be PLAYOFF basic tournament)
  round        Int      // Round number (1 = first round, 2 = semifinals, etc.)
  position     Int      // Position within the round (1, 2, 3, ...)
  member1Id    Int?     // Member 1 ID (null if not yet determined from previous round, 0 for BYE)
  member2Id    Int?     // Member 2 ID (null if not yet determined from previous round, 0 for BYE)
  nextMatchId  Int?     // ID of the BracketMatch in the next round that the winner advances to
  matchId      Int?     // Reference to Match when match is created (both players determined)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tournament      Tournament     @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  nextMatch       BracketMatch?  @relation("BracketMatchAdvancement", fields: [nextMatchId], references: [id])
  previousMatches BracketMatch[] @relation("BracketMatchAdvancement")
  match           Match?         @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@unique([tournamentId, round, position])
  @@unique([matchId]) // One BracketMatch per Match
  @@index([tournamentId])
  @@index([tournamentId, round, position])
  @@index([nextMatchId])
  @@index([matchId])
  @@map("bracket_matches")
}

// Match: stores actual match results for basic tournaments and standalone matches
// Each match references one basic tournament OR can be standalone (tournamentId = null)
// Matches are not tournaments - they record results played as part of a basic tournament
// BracketMatch references Match (via matchId) when match is created with both players determined
model Match {
  id             Int      @id @default(autoincrement())
  tournamentId   Int?     // Foreign key to basic tournament (ROUND_ROBIN, PLAYOFF, or SWISS) - null for standalone matches
  member1Id      Int
  member2Id      Int?     // Nullable for BYE matches
  player1Sets    Int      @default(0)
  player2Sets    Int      @default(0)
  player1Forfeit Boolean  @default(false)
  player2Forfeit Boolean  @default(false)
  round          Int?     // Round number for Swiss tournaments (null for other types)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tournament Tournament? @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  bracketMatch BracketMatch? // Reverse relation: BracketMatch references this Match via matchId

  @@index([tournamentId])
  @@index([member1Id])
  @@index([member2Id])
  @@index([member1Id, member2Id])
  @@map("matches")
}

model PointExchangeRule {
  id             Int      @id @default(autoincrement())
  minDiff        Int // Minimum rating difference (inclusive)
  maxDiff        Int // Maximum rating difference (inclusive)
  expectedPoints Int // Points for expected result (higher-rated player wins)
  upsetPoints    Int // Points for upset (lower-rated player wins)
  effectiveFrom  DateTime @default(now()) // When this rule becomes effective (allows future modifications)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([minDiff, maxDiff, effectiveFrom])
  @@index([effectiveFrom])
  @@map("point_exchange_rules")
}

// PreliminaryRoundRobinConfig: Configuration for PRELIMINARY_WITH_FINAL_ROUND_ROBIN tournaments
// Stores final round robin size, auto-qualification settings
model PreliminaryRoundRobinConfig {
  id                     Int      @id @default(autoincrement())
  tournamentId           Int      @unique
  finalRoundRobinSize    Int      // Desired size of the final round robin
  autoQualifiedCount     Int      @default(0) // Number of auto-qualified players (highest rated, skip preliminary)
  autoQualifiedMemberIds Int[]    // Member IDs of auto-qualified players

  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@map("preliminary_round_robin_configs")
}

// SwissTournamentData: Configuration for SWISS tournaments
// Stores round count, pairing strategy, and completion state
model SwissTournamentData {
  id             Int      @id @default(autoincrement())
  tournamentId   Int      @unique
  numberOfRounds Int
  pairByRating   Boolean  @default(true)
  currentRound   Int      @default(0)
  isCompleted    Boolean  @default(false)

  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@map("swiss_tournament_data")
}
